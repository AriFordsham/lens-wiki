h2. General FAQs

* "What are goals of this project?":#goals
* "How do you determine what falls into the scope of @lens@?":#scope
* "Will you be splitting out a separate @lens-core@ package?":#lens-core
* "Wasn't @fclabels@ or @data-lens@ good enough for you?":#good-enough

h2. Usage Guidelines

* "When should I define or use a @Getter@ rather than a function?":#using-getters

***

h3=. General

h4. <a name="goals">Q:</a> What are the goals of this project? Why does this project exist?

*A:* The @lens@ library exists to provide more composable versions of the abstractions you already know how to use in Haskell. Every Haskell programmer already knows how to work with functors and functions or @Foldable@ and @Traversable@ containers. 

We simply provide you with a vocabulary for composing them and working with their compositions.

One goal of @lens@ has been to provide a consistent vocabulary that lets you access and work with data.

h4. <a name="scope">Q:</a> How do you determine what falls into the scope of @lens@?

As a rule @lens@ incurs no package dependency that is not either in the <a href="http://www.haskell.org/platform/">Haskell Platform</a> *or* required to implement its own functionality.

That said, we've tried to provide a "Batteries Included" API that provides useful tools for operating with anything that *does* fall into its scope.

h4. <a name="lens-core">Q:</a> Will you be splitting out a separate @lens-core@ package? The @build-depends:@ list has a lot of stuff I don't use.

*A:* This is on the surface a very reasonable request, but it doesn't work very well in practice. To implement even basic @lens@ functionality requires a number of language extensions.

Consider the extensions needed to break out the types and combinators for lenses, traversals, etc. separately from the rest of the package. We'd need @Rank2Types@ to even write @Lens@. Working with indexed lenses needs @TypeFamilies@, because without type equality coercions type inference for them is unusable. By the time we get done with @Projection@ and @Iso@ we've brought in a whole pile of extensions and already tied ourselves to the <a href="http://www.haskell.org/ghc/">Glorious Glasgow Haskell Compiler</a>.

Even with just this functionality, implementing these combinators already dragged in the @mtl@ and a large number of dependencies. We had to define a large number of internal types along the way, types we actually expose elsewhere to the user in the API, like @Context@ and @Bazaar@, which have useful @Comonad@ instances. This forces us to implement them correctly, orphan those instances or remove functionality.

Since we're already tied to GHC, and the Template Haskell code generator for @makeLenses@ and @makeClassy@ is key to making the library usable, it makes sense to incorporate that directly into the base package. Implementing that brings with it dependencies on @containers@.

The combinators in @Control.Lens.Plated@ are generally useful when working with any @Traversal@ and we use @Plated@ internally.

One part we *could* splinter out into a separate package are the combinators in @Control.Lens.Zipper@, but they are sort of the "killer app" for lenses and having them brought into scope by default with the rest of @Control.Lens@ minimizes confusion and encourages their adoption.

h4. <a name="good-enough">Q:</a> Wasn't @fclabels@ or @data-lens@ good enough for you?

Most of the power of @lens@ comes from working with generalizations of the notion of a Van Laarhoven lens. 

None of @fclabels@, @data-lens@, @data-accessor@, @lenses@, @yall@, etc. provided this style of lens and most had attempted to generalize the idea of a @Lens@ by shoe-horning a @Monad@ or some other notion of partiality into the middle of it. This came at the expense of the laws that made working with lenses worth doing.

Providing lenses for any of these libraries required picking up a dependency on a package, which means that it is really impractical or impossible for a reasonably "core" package on hackage to reasonably provide lenses for them.

However, the style of lenses used by @lens@ can be defined using functions from the @Prelude@. No dependencies need be incurred to *supply* lenses, merely to use them!

There really wasn't a good library for working with Van Laarhoven lens families when @lens@ was started. @lens-family@ had tried to be that library, but it required 3 separate packages to work with and used the same names between its Haskell 98 @lens-family-core@ package and the main @lens-family@ package. Moreover, it is shackled by Haskell 98. That said, the combinators for working with lenses from @lens-family-core@ are mostly compatible with the lenses provided by or for use by this package.

By adopting and generalizing van Laarhoven lenses we are able to provide a better user experience, because almost any lens, projection, traversal, isomorphism, etc. that the user goes to reach for can be used with any combinator and it just "does the right thing". Explicit conversions are mostly eliminated.

***

h3=. Usage Guidelines

h4. <a name="using-getters">Q:</a> When should I define or use a @Getter@ rather than a function?

*A:* In general you shouldn't bother defining values that are just a @Getter@. It is almost always
a better idea to just supply a function, and then drop it into the chain of lenses or traversals with @to@,
or by simply applying it to the final result.