h2. General FAQs

* "What are goals of this project?":#goals
* "How do you determine what falls into the scope of @lens@?":#scope
* "Will you be splitting out a separate @lens-core@ package?":#lens-core

h2. Usage Guidelines

* "When should I define or use a @Getter@ rather than a function?":#using-getters

***

h3=. General

h4. <a name="goals">Q:</a> What are the goals of this project? Why does this project exist?

*A:* The @lens@ library exists to provide more composable versions of the abstractions you already know how to use in Haskell. Every Haskell programmer already knows how to work with functors and functions or @Foldable@ and @Traversable@ containers. 

We simply provide you with a vocabulary for composing them and working with their compositions.

h4. <a name="scope">Q:</a> How do you determine what falls into the scope of @lens@?

As a rule @lens@ incurs no package dependency that is not either in the Haskell Platform or required to implement its own functionality. That said, we've tried to provide a "Batteries Included" API that provides useful tools for operating with anything that *does* fall into its scope.

h4. <a name="lens-core">Q:</a> Will you be splitting out a separate @lens-core@ package? The @build-depends:@ list has a lot of stuff I don't use.

*A:* This is on the surface a very reasonable request, but it doesn't work very well in practice. To implement even basic @lens@ functionality requires a number of language extensions.

Consider the extensions needed to break out the types and combinators for lenses, traversals, etc. separately from the rest of the package. We'd need @Rank2Types@ to even write @Lens@. Working with indexed lenses needs @TypeFamilies@, because without type equality coercions type inference for them is unusable. By the time we get done with @Projection@ and @Iso@ we've brought in a whole pile of extensions and already tied ourselves to the Glasgow Haskell Compiler.

Even with just this functionality, implementing these combinators already dragged in the @mtl@ and a large number of dependencies. We had to define a large number of internal types along the way, types we actually expose elsewhere to the user in the API, like @Context@ and @Bazaar@, which have useful @Comonad@ instances. This forces us to implement them correctly, orphan those instances or remove functionality.

Since we're already tied to GHC, and the Template Haskell code generator for @makeLenses@ and @makeClassy@ is key to making the library usable, it makes sense to incorporate that directly into the base package. Implementing that brings with it dependencies on @containers@.

The combinators in @Control.Lens.Plated@ are generally useful when working with any @Traversal@ and we use @Plated@ internally.

One part we *could* splinter out into a separate package are the combinators in @Control.Lens.Zipper@, but they are sort of the "killer app" for lenses and having them brought into scope by default with the rest of @Control.Lens@ minimizes confusion and encourages their adoption.

***

h3=. Usage Guidelines

h4. <a name="using_getters">Q:</a> When should I define or use a @Getter@ rather than a function?

*A:* In general you shouldn't bother defining values that are just a @Getter@. It is almost always
a better idea to just supply a function, and then drop it into the chain of lenses or traversals with @to@,
or by simply applying it to the final result.